From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Calvin Watford <watfordcalvin@gmail.com>
Date: Thu, 2 Jan 2025 20:46:56 -0700
Subject: [Corner Smoothing] Painting smooth corners

TODO: merge all patches together

diff --git a/third_party/blink/renderer/core/paint/rounded_border_geometry.cc b/third_party/blink/renderer/core/paint/rounded_border_geometry.cc
index 1641321846aeaca69df21125141c722f76b27ebc..84137b7bdd7b4edb0ddf854887e945e1694b23d5 100644
--- a/third_party/blink/renderer/core/paint/rounded_border_geometry.cc
+++ b/third_party/blink/renderer/core/paint/rounded_border_geometry.cc
@@ -42,6 +42,7 @@ FloatRoundedRect RoundedBorderGeometry::RoundedBorder(
     rounded_rect.SetRadii(
         CalcRadiiFor(style, gfx::SizeF(border_rect.size), PhysicalBoxSides()));
     rounded_rect.ConstrainRadii();
+    rounded_rect.SetSmoothness(style.ElectronCornerSmoothing());
   }
   return rounded_rect;
 }
@@ -55,6 +56,7 @@ FloatRoundedRect RoundedBorderGeometry::PixelSnappedRoundedBorder(
     rounded_rect.SetRadii(
         CalcRadiiFor(style, gfx::SizeF(border_rect.size), sides_to_include));
     rounded_rect.ConstrainRadii();
+    rounded_rect.SetSmoothness(style.ElectronCornerSmoothing());
   }
   return rounded_rect;
 }
@@ -68,6 +70,7 @@ FloatRoundedRect RoundedBorderGeometry::RoundedInnerBorder(
                            .set_right(style.BorderRightWidth())
                            .set_bottom(style.BorderBottomWidth())
                            .set_left(style.BorderLeftWidth()));
+  rounded_border.SetSmoothness(style.ElectronCornerSmoothing());
   return rounded_border;
 }
 
@@ -113,6 +116,7 @@ FloatRoundedRect RoundedBorderGeometry::PixelSnappedRoundedBorderWithOutsets(
         PixelSnappedRoundedBorder(style, border_rect, sides_to_include);
     pixel_snapped_rounded_border.Outset(gfx::OutsetsF(adjusted_outsets));
     rounded_rect.SetRadii(pixel_snapped_rounded_border.GetRadii());
+    rounded_rect.SetSmoothness(style.ElectronCornerSmoothing());
   }
   return rounded_rect;
 }
diff --git a/third_party/blink/renderer/platform/geometry/float_rounded_rect.h b/third_party/blink/renderer/platform/geometry/float_rounded_rect.h
index 95d4498a0e0b3484ecbf9fe50f5aef49a68b5dcb..70c32c806e3454175e4433e8072b3aee10bb0c25 100644
--- a/third_party/blink/renderer/platform/geometry/float_rounded_rect.h
+++ b/third_party/blink/renderer/platform/geometry/float_rounded_rect.h
@@ -34,6 +34,7 @@
 #include <iosfwd>
 #include <optional>
 
+#include "electron/shell/renderer/electron_smooth_round_rect.h"
 #include "third_party/blink/renderer/platform/platform_export.h"
 #include "third_party/blink/renderer/platform/wtf/allocator/allocator.h"
 #include "third_party/blink/renderer/platform/wtf/text/wtf_string.h"
@@ -135,11 +136,14 @@ class PLATFORM_EXPORT FloatRoundedRect {
 
   constexpr const gfx::RectF& Rect() const { return rect_; }
   constexpr const Radii& GetRadii() const { return radii_; }
+  constexpr float Smoothness() const { return smoothness_; }
   constexpr bool IsRounded() const { return !radii_.IsZero(); }
   constexpr bool IsEmpty() const { return rect_.IsEmpty(); }
+  constexpr bool IsSmooth() const { return smoothness_ > 0.0f; }
 
   void SetRect(const gfx::RectF& rect) { rect_ = rect; }
   void SetRadii(const Radii& radii) { radii_ = radii; }
+  void SetSmoothness(float smoothness) { smoothness_ = smoothness; }
 
   void Move(const gfx::Vector2dF& offset) { rect_.Offset(offset); }
 
@@ -214,6 +218,13 @@ class PLATFORM_EXPORT FloatRoundedRect {
   // the rounded border.
   void ConstrainRadii();
 
+  SkPath SmoothPath() const {
+    return electron::DrawSmoothRoundRect(
+        rect_.x(), rect_.y(), rect_.width(), rect_.height(), smoothness_,
+        radii_.TopLeft().width(), radii_.TopRight().width(),
+        radii_.BottomRight().width(), radii_.BottomLeft().width());
+  }
+
   explicit operator SkRRect() const;
   explicit operator gfx::RRectF() const { return gfx::RRectF(SkRRect(*this)); }
 
@@ -222,6 +233,7 @@ class PLATFORM_EXPORT FloatRoundedRect {
  private:
   gfx::RectF rect_;
   Radii radii_;
+  float smoothness_;
 };
 
 inline FloatRoundedRect::operator SkRRect() const {
diff --git a/third_party/blink/renderer/platform/graphics/graphics_context.cc b/third_party/blink/renderer/platform/graphics/graphics_context.cc
index 8503c0d22d68f63e0015bb76507dd22484d3a6d7..3cae5bfccdd2353ee92c3d94e4da68cbc7f52b19 100644
--- a/third_party/blink/renderer/platform/graphics/graphics_context.cc
+++ b/third_party/blink/renderer/platform/graphics/graphics_context.cc
@@ -641,6 +641,7 @@ void GraphicsContext::DrawImageRRect(
         image.ApplyShader(image_flags, local_matrix, src_rect, draw_options);
   }
 
+  // TODO: smooth rounding
   if (use_shader) {
     // Temporarily set filter-quality for the shader. <reed>
     // Should be replaced with explicit sampling parameter passed to
@@ -809,6 +810,14 @@ void GraphicsContext::FillRoundedRect(const FloatRoundedRect& rrect,
 
   const cc::PaintFlags& fill_flags = ImmutableState()->FillFlags();
   const SkColor4f sk_color = color.toSkColor4f();
+
+  if (rrect.IsSmooth()) {
+    cc::PaintFlags flags = fill_flags;
+    flags.setColor(sk_color);
+    DrawPath(rrect.SmoothPath(), flags, auto_dark_mode);
+    return;
+  }
+
   if (sk_color == fill_flags.getColor4f()) {
     DrawRRect(SkRRect(rrect), fill_flags, auto_dark_mode);
     return;
@@ -872,6 +881,7 @@ void GraphicsContext::FillDRRect(const FloatRoundedRect& outer,
   const cc::PaintFlags& fill_flags = ImmutableState()->FillFlags();
   const SkColor4f sk_color = color.toSkColor4f();
   if (!IsSimpleDRRect(outer, inner)) {
+    // TODO: smooth rounding
     if (sk_color == fill_flags.getColor4f()) {
       canvas_->drawDRRect(SkRRect(outer), SkRRect(inner),
                           DarkModeFlags(this, auto_dark_mode, fill_flags));
@@ -903,6 +913,7 @@ void GraphicsContext::FillRectWithRoundedHole(
     const FloatRoundedRect& rounded_hole_rect,
     const Color& color,
     const AutoDarkMode& auto_dark_mode) {
+  // TODO: smooth rounding
   cc::PaintFlags flags(ImmutableState()->FillFlags());
   flags.setColor(color.toSkColor4f());
   canvas_->drawDRRect(SkRRect::MakeRect(gfx::RectFToSkRect(rect)),
@@ -951,6 +962,10 @@ void GraphicsContext::ClipRoundedRect(const FloatRoundedRect& rrect,
     ClipRect(gfx::RectFToSkRect(rrect.Rect()), should_antialias, clip_op);
     return;
   }
+  if (rrect.IsSmooth()) {
+    ClipPath(rrect.SmoothPath(), should_antialias, clip_op);
+    return;
+  }
 
   ClipRRect(SkRRect(rrect), should_antialias, clip_op);
 }
